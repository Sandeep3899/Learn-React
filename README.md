# Learn React

Components
Header

- Logo
- Search
- Home
- Location
- pickup/Delivery
- Notifications
- Cart

Body

- Restaurant Cointainer
- Restaurant Card
- img
- Restaurant Name
- Cuisine Type
- Rating

- Delivery Time
  Footer
- About Us
- Copyright
- Contact Us
- Privacy Policy
- Help

- npm start

To commit changes to github:

- git add .
- git commit -m "message"
- git push

Package.json is a configuration of npm,
why do we need this to manage dependencies npm will take care of the version of the package

Webpack, Parcel, and Vite are popular tools in JavaScript development used for bundling and optimizing code for web applications.
While they all serve the purpose of transforming and packaging code

In our project we are using Parcel, is a library

# npm install -D Parcel

why -D:
there are two types of dependencies
1.Dev dependencies(development phase)
2.Normal dependencies(in production)

to check version - npm parcel --version

In a package.json file, the caret (^) and
tilde (~) symbols are used to define version ranges for package dependencies

- For example, ^1.2.3 would allow updates to 1.2.4, 1.3.0, or 1.9.9, but not 2.0.0.
- For example, ~1.2.3 would allow updates to 1.2.4, 1.2.5, but not 1.3.0 or 2.0.0.

package-lock.json:
This file is automatically generated and updated by npm to lock down the exact versions of all installed dependencies,
including sub-dependencies

package.json:
This file acts as the project's manifest, containing metadata about the project itself (name, version, author, license)
and defining its direct dependencies.

.gitignore- it contains files that are not required to upload to github like the node_modules

- to ignite the App - "npx parcel index.html" or "npx parcel build index.html" for production ode
- npm to install
- npx to excute the package

- to bring react into the project cdn links isn't a good way
  better way is to get react as a dependencies with npm
- to install - npm install or i(shortcut for install) react not -D cause we want install react as normal dependency
- to install react dom - npm i react-dom

Parcel:(parceljs.org)

- Dev Build
- Local Server
- HMR = Hot Module Replacement
- File Watching Algorithm - written in C++
- Caching - For faster builds
- Image optimizing
- Minification
- bundling
- Compressing
- Consistent Hashing: a distributed hashing scheme that minimizes data redistribution when nodes are added or removed from a system
- Code Splitting
- Differential Bundling - support older browsers
- Diagnostics
- Error Handling
- HTTPs
- Tree Shaking Algorithm- remove unused code for you
- Different dev and prod bundles

npx parcel build intex.html for production

- go to package.json -> scripts we can create short cut for the commands
- now instead of "npx parcel index.html" we enter "npm run start" or ("npm start" this is only work for start)

- this is more complex right? it is not developer friendly and hard to read
  const heading = React.createElement("h1",{id: "heading1"}, "Learn React");
- So JSX(Jav Script React) is created, it is not a part of react both are Different
  -We can build React without JSX. to simply React we use JSX
  "const jsxHeading = <h1>Learn React using JSX</h1>;"
- JSX is not HTML, it looks like HTML/XML but not HTML/XML

"const jsxHeading = <h1>Learn React using JSX</h1>;"

- is this valid javascript -> NO -> JS engine cannot understand JSX
- JS enginer understand ES6(ECMAscript)
- jsx (Tranpiled before it reaches the JS engine) this is done by Parcel -> Babel(convert jsx to react code)
- attibutes are given as Camel case(camelCase)
- single line is fine, if you want to write in multiple lines wrap in ();

React Components:

- Every thing in React is a Component
- Two types of Components

1. class based - OLD way no one uses now
2. functional Component - NEW way of writing codes

- A funstion that returns a piece of JSX code
- If a function that returns a react element it is functional Component
- It starts with a Capital letter
- To render a react component we do "root.render(<HeadingComponenet />)"

8/1/2025
Building realworld application:

Step: 1 - Plan things out, then coding is easy

For dynamic data we use Props

- Props is a short form of properties - Arguments to our functions

- Config drivin UI: Our website is drivin by data/config, controlling ui based on data. (website may vary based on location)

- clean the code

- How to loop a function we can use js map function

- not using key(not acceptable) <<<<<< using index <<<<<< using unique key(best practice)

Chapter 05: React Hooks

- structure the app using common industry methods

two types of exports as shown below

- to import 1st we need to export(
  export default Header;
  import Header from "./components/Header";)

- we can only have 1 default export for a file as shown above, if we need to export multiple things from a same file use
- name export
  export const Component
  import {Component} from "path";

- Lets build a filter like top rated restaurant
- we use js filter function
  onClick={() => {
  // Filter logic here
  listOfRestaurants = listOfRestaurants.filter(
  (res) => res.avgRating > "4"
  );
  console.log(listOfRestaurants);
  }}

- React is fast beacuse, it can update DOM effieiently, faster DOM manipulation
  #React Hooks
- Hook is a normal JavaScript function given by react, it comes with super power. written by Facebook developers

1. useState() - superpowerful State Variables in React. when ever state variable changes, react will rerender the component
2. useEffect() - Render the component as soon as finshed it will call the useEffect function - If you have to do something after rendering the component we have to write the code in useEffect()
   these are two most important hooks we use them 99% of times

#HOW reat works in background?

- Reconciliation Algorithm (React Fiber) - React16 this algo is added

                  O res-container
                  |
          -----------------
          |               |   =>  UI changes -> 7 to 3 cards
          O---------------O
              7 res cards

              Virtual DOM

  -Diff Algorithm will find the difference between the updated virtual dom and the prev virtual dom and then it updates the original DOM

#Let Explore React

- Monolith architcure, we have API, UI, AUth, Database, SMS - we have to deploy the whole project.
- Now world is moving towards Microservices architcure, we have diff services for diff jobs.
  - we have Backend, we have UI, we have Auth, we have database, we have SMS services all these combined call microserviecs.
  - this is know as serparation of concerns, and single responsibility principle.
- Monolith everything needs to written in one lang for everything
- For microserviecs we can use diff langauges for each services
  - these run on own specific ports eg for ui: 1234
  - these run on own specific ports eg for backend: 1267 all these connect by call /ui or /backend

# There are 2 Approaches how ui fetch data from backend:

1.

- Loads -> api call to fetch data -> render
  this call takes 500 ms

2.  - As soon as page loades -> renedr ui -> Now Api call -> Render ui with data (always use this in React)
    - this btr for UX

- we use useEffect() for this

- fetch() is a super power given by browsers
- async()

#Lets build useEffect is a normal function which render -> load data -> rerender

- For better user experience we use some loading till the content displays
  if (listOfRestaurants.length === 0) {
  return <h2>Loading...</h2>;
  }

- latest tech using shimmer ui like loading fake cards refresh utube
- This is much better, this is standard practice in industry now

# if (listOfRestaurants.length === 0) {

    return <Shimmer />;

}

- this is conditional rendering

#Why do we even have useState()

- lets understand with an exmple building login/logout button

#Lets build Search function

- Whenever state variables update, react triggers a Reconciliation cycle(re-render the component)

#3 cases for useEffect():
useEffect(() => {
console.log("useEffect called");
});
#When is useEffect is called

- it will be called every rendered useEffect will be called
- if there is no dependency array => useEffect is called on every component render
  useEffect(() => {
  console.log("useEffect called");
  , []});
- if the dependency array is empty [] then useEffect is called on only initial render(just once)
  useEffect(() => {
  console.log("useEffect called");
  , [btnNameReact]});
- if there is something in dependency array, then it will only be called only if the dependency changes

#useState(): best practices:

- it is used to create local state variable in side your functional componenets
- never save state variables outside the body
- always call useState variable only in body
- try to call hooks on the top, so that you dont have inconsistencty in the code
- never create ur useState in if else, its valid but never do this.
- never create ur useState in for loop.
- never create ur useState in function()

#Routing session:

- we going to npm router library
- npm i react-router-dom
- createBrowserRouter
- RouterProvider provide config
- We can use - useRoutError to show the error page
- How to create children routers, so we can keep header and footer on every page we visit

const appRouter = createBrowserRouter([
{
path: "/",
element: <AppLayout />,
children: [
{
path: "/about",
element: <About />,
},
{
path: "/contact",
element: <Contact />,
},
],
errorElement: <Error />,
},
]);

- React Router Outlet, this helps to load the content based on the page we are in by keeping header and footer in place
  const AppLayout = () => {
  return (
  <div className="app">
  <Header />
  <Outlet />
  <Footer />
  </div>
  );
  };

- in react-router-dom we have link, to redirect to other pages instead of anchor href in html.
<Link To="/About"> About Us <Link/>

#There are 2 types of routing in web applications

1. Client Side Routing - Above we did is this, we are not fetching a new page.
2. Server Side Routing

#till now we learned about functional based components, in class 08 we will learn about class based components which a old way of creating components. we never use them but good/imp to know may be asked in interviews

- it says how react life cycle works.
- we'll start experimenting on About US page of our project
  CLass based component Ex:
  class UserClass extends React.Component {
  render() {
  return (
  <div className="user-card">
  <h2>User Name: Sandeep Reddy Yeruva</h2>
  <h3>Age: 30</h3>
  <p>Email: sandep.yeruva@gmail.com</p>
  </div>
  );
  }
  }

Function based component Ex:
const User = () => {
return (

<div className="user-card">
<h2>User Name: Sandeep Reddy Yeruva</h2>
<h3>Age: 30</h3>
<p>Email: sandep.yeruva@gmail.com</p>
</div>
);
};
export default User;

# When component is loaded, 1st parent constroctor is called then the parent render is called

# Now child constructor is called then the child render is called

# Now child mounting is completed then componentDIdMount is called

# Once child fisnished successfully now the parent componentDidMount is called

Parent Constructor
Parent Render
Child Constructor
Child Render
Child Component Did Mount
Parent Component Did Mount

# ComponentDidMount is used To make API calls, But why we do that

- lets to functional component
- we make API call using useEffect
  useEffect(() =>{
  },[]);
- Load -> Basic Render -> API Call -> Render this how we need react to work
- In order to achive above we use below
- for API call in class based we use componentDidMount

# React have 2 phases:

- Render phase
- Commit phase

Parent Constructor
Parent Render
1stChild Constructor
1stChild Render
2ndChild Constructor
2ndChild Render
3rdchild Constructor
3rdChild Render
1stchild Component Did Mount
2ndChild Component Did Mount
3rdChild Component Did Mount
Parent Component Did Mount

- it will happen in batches, render phase in batches then Mount phase in batches

ReactLifecycle link:
https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

This is how the whole lifecycle looks like:

1. Constructor (dummy)
2. Render (dummy)
   <html Dummy>
3. Component Did Mount
   <API Call>
   <this.setState> -> State Variable is updated

------------Update (dummy)

          render(API data)
          <HTML (new API data)>
          ComponentDid Update
